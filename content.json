{"meta":{"title":"WinterTitle","subtitle":null,"description":null,"author":"Winter","url":"https://github.com/b348068721","root":"/"},"pages":[],"posts":[{"title":"ReactiveCocoa与响应式编程（FRP）","slug":"ReactiveCocoa","date":"2019-03-23T15:16:11.085Z","updated":"2019-03-23T15:35:19.358Z","comments":true,"path":"2019/03/23/ReactiveCocoa/","link":"","permalink":"https://github.com/b348068721/2019/03/23/ReactiveCocoa/","excerpt":"","text":"响应式编程概述是一种编程范式、思想，无法从源码方式获得答案，是一种抽象能力 原始模式：输入设备-&gt;计算设备-&gt;输出设备常用模式：业务需求-&gt;模式-&gt;代码面向对象（Objective-C）与面向过程（C）都属于命令式编程命令式运算：寄存器的运算，改变寄存器的值，不表示相互关系响应式编程：类似excel表格计算，当求和中某一个元素值改变，结果随之改变。一个对象随着其他对象改变而改变（如autolayout）12345678910111213141516//基于语句的运算，状态量的运算- (NSInteger)factorial1:(NSInteger)x &#123;int result = 1;for (int i = 1; i &lt; x; i++) &#123;result *= i;&#125;return result;&#125;//没有创建变量，描述的是一种运算，表达式的运算，非状态量的运算- (NSInteger)factorial2:(NSInteger)x &#123;if (x == 1) &#123;return 1;&#125;return x * [self factorial2:(x - 1)];&#125; 函数响应式编程和ReactiveCocoa是什么函数响应式编程满足函数式的一些特性面向离散事件流离散事件流操作特性：闭包&amp;高阶函数 惰性计算 不改变状态 递归 ReactiveCocoaFRP在Cocoa框架下的实现富含了Cocoa框架多种组件提供基于时间变化的数据流的组合和变换 理论基础理解基于时间变化的数据流 数组对比流流在时间变化，视频或音频数组空间的有序，无法判断时间间隔 流的操作对值的操作对数量的操作对维度的操作对时间间隔的操作 基础知识-核心组件RACSteam子类由RACSequence和RACSingal组成 RACSequence（空间数据流，类似数组、链表）Pull-driver：看书，看不看，看多少由我决定Data基于惰性计算，大规模计算时对性能要求高 RACSingal(时间数据流)Push-driver：看电视，不论我看不看一直播放Event离散的，性能消耗较小 single Subscriber Disposable三者关系Scheduler调度代替GCD异步与并发 框架适配工具","categories":[],"tags":[{"name":"Objecive-C","slug":"Objecive-C","permalink":"https://github.com/b348068721/tags/Objecive-C/"},{"name":"ReactiveCocoa","slug":"ReactiveCocoa","permalink":"https://github.com/b348068721/tags/ReactiveCocoa/"},{"name":"FRP","slug":"FRP","permalink":"https://github.com/b348068721/tags/FRP/"}]},{"title":"链式编程","slug":"ChainingProgram","date":"2019-03-21T06:20:23.396Z","updated":"2019-03-21T07:37:33.549Z","comments":true,"path":"2019/03/21/ChainingProgram/","link":"","permalink":"https://github.com/b348068721/2019/03/21/ChainingProgram/","excerpt":"","text":"在iOS开发界面布局的库中我们经常使用SDAutoLayout和Masonry,在这我们不讨论如何使用，好奇的是两个框架是如何写出下边的代码，像这种通过”.”的方法将需要执行的代码链接到一起的技巧，成为链式编程。这种方式是我们书写和阅读代码更为容易。个人理解链式编程应该属于一种编程技巧，不属于编程思想。12//SDAutoLayoutbutton.sd_layout.leftEqualToView(inView).topSpaceToView(inView, 0).rightEqualToView(inView).heightRatioToView(inView, 1); 1234//Masonry[view mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.top.bottom.left.right.equalTo(self.view);&#125;]; 乍一看链式编程好像比较高科技，经过思考我将链式编程通过以下几步进行了分解，方便理解。 声明1234567@interface ChainingProgram()@property (nonatomic, assign) int total;- (void)calculate;- (ChainingProgram *)add:(int)a;- (void (^)(int))block;- (ChainingProgram *(^)(int))addBlock;@end 普通的OC方法123- (void)calculate &#123; NSLog(@\"normal_Calculate\");&#125; 调用1[self calculate]; 返回值为当前类的对象的oc方法12345- (ChainingProgram *)add:(int)a &#123; NSLog(@\"add_%d\",a); self.total += a; return self;&#125; 调用这里和链式编程的区别是不是还有一个”[ ]”的距离1[[[[self add:1]add:2]add:3]total]; 没有返回值的block的实例方法123456- (void (^)(int))block &#123; void (^result) (int) = ^ (int a) &#123; NSLog(@\"block_%d\",a); &#125;; return result;&#125; 调用block作为属性传递12void (^result)(int) = [self block];result(4); 带返回值为当前类对象的block的实例方法123456789- (ChainingProgram *(^)(int))addBlock &#123; __weak typeof(self) weakSelf = self; ChainingProgram *(^result)(int) = ^(int a) &#123; NSLog(@\"addBlock__%d\",a); weakSelf.total += a; return self; &#125;; return result;&#125; 也可以缩写为12345678- (ChainingProgram *(^)(int))addBlock &#123; __weak typeof(self) weakSelf = self; return ^(int a)&#123; NSLog(@\"addBlock__%d\",a); weakSelf.total += a; return self; &#125;;&#125; 调用1[self.addBlock(5).addBlock(6).addBlock(7) total]; 简单说我们熟悉add方法，也熟悉block方法，只要将两者加起来就成为了熟悉又陌生的链式编程方法（addBlock）","categories":[],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"https://github.com/b348068721/tags/Objective-C/"},{"name":"Chaining","slug":"Chaining","permalink":"https://github.com/b348068721/tags/Chaining/"}]},{"title":"SDWebImage项目中的应用","slug":"SDWebImage实际应用","date":"2019-03-12T14:56:03.108Z","updated":"2019-03-13T15:24:08.631Z","comments":true,"path":"2019/03/12/SDWebImage实际应用/","link":"","permalink":"https://github.com/b348068721/2019/03/12/SDWebImage实际应用/","excerpt":"","text":"我们在面试中常被问到知名三方库的使用原理，我们经常认为这些原理对我们真正工作当时的帮助不大，但是随着项目不断迭代，对APP的性能及稳定提出越来越多的要求。我们逐渐会接触到通过三方库原理去思考使用三方库的策略来方便开发。这篇描述的是一个SDWebImage的使用案例。 安装与简单使用安装cocoaPods-&gt;Podfile12platform :ios, &apos;7.0&apos;pod &apos;SDWebImage&apos;, &apos;~&gt; 4.0&apos; 简单使用引入头文件1#import &lt;SDWebImage/UIImageView+WebCache.h&gt; 加载网络图片12[imageView sd_setImageWithURL:[NSURL URLWithString:@\"http://www.domain.com/path/to/image.jpg\"]placeholderImage:[UIImage imageNamed:@\"placeholder.png\"]]; 项目中使用对于SDImageCache的应用阅读源码我们发现SDImageCache类负责管理内存缓存和磁盘缓存，为了方便调用它提供了一个单例sharedImageCache，之前也都是一直使用这个方法，但是遇到这个需求后变化就来了。 情景即时聊天，要求做图片缓存（类似微信），要求每个conversation以conversationId为文件夹名字，将当前conversation中的图片存入该文件夹中，并且在不使用一键清除缓存的情况下，图片一致保留。 SDImageCache方案默认的路径1沙盒中的Cache 默认的缓存方案1234先清除已超过最大缓存时间的缓存文件（最大缓存时间默认为一星期）在第一轮清除的过程中保存文件属性，特别是缓存文件大小在第一轮清除后，如果设置了最大缓存并且保留下来的磁盘缓存文件仍然超过了配置的最大缓存，那么进行第二轮以大小为基础的清除。首先删除最老的文件，直到达到期望的总的缓存大小，即最大缓存的一半。 情景方案路径在SDImageCache的头文件中1234567891011121314151617181920212223/*** Returns global shared cache instance** @return SDImageCache global instance*/+ (nonnull instancetype)sharedImageCache;/*** Init a new cache store with a specific namespace** @param ns The namespace to use for this cache store*/- (nonnull instancetype)initWithNamespace:(nonnull NSString *)ns;/*** Init a new cache store with a specific namespace and directory** @param ns The namespace to use for this cache store* @param directory Directory to cache disk images in*/- (nonnull instancetype)initWithNamespace:(nonnull NSString *)nsdiskCacheDirectory:(nonnull NSString *)directory NS_DESIGNATED_INITIALIZER; 使用这些来创建另外的命名空间 缓存方案仿照SDImageCache的实现进行修改，删除缓存的时间及清除12345678910111213141516/*** Clear all memory cached images*/- (void)clearMemory;/*** Async clear all disk cached images. Non-blocking method - returns immediately.* @param completion A block that should be executed after cache expiration completes (optional)*/- (void)clearDiskOnCompletion:(nullable SDWebImageNoParamsBlock)completion;/*** Async remove all expired cached image from disk. Non-blocking method - returns immediately.* @param completionBlock A block that should be executed after cache expiration completes (optional)*/- (void)deleteOldFilesWithCompletionBlock:(nullable SDWebImageNoParamsBlock)completionBlock;","categories":[],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"https://github.com/b348068721/tags/Objective-C/"},{"name":"markdown","slug":"markdown","permalink":"https://github.com/b348068721/tags/markdown/"},{"name":"SDWebImage","slug":"SDWebImage","permalink":"https://github.com/b348068721/tags/SDWebImage/"}]},{"title":"建站成功","slug":"helloworld","date":"2019-03-12T14:56:03.108Z","updated":"2019-03-12T15:53:07.948Z","comments":true,"path":"2019/03/12/helloworld/","link":"","permalink":"https://github.com/b348068721/2019/03/12/helloworld/","excerpt":"","text":"代码没写出什么花样，但是花边没少看，这是借助hexo、github创建的个人站，花的时间不多，值得玩玩。建站步骤 安装Node.jsGit 安装完成执行命令(速度慢换镜像！)1$ npm install -g hexo-cli 建站1234$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 自定义自己的站（高玩都是自己写，可惜我只会套用） _config.yml文件的配置 选一个喜欢的themes 配置themes,注意themes中也有一个_config.yml别弄混了 生成1$ hexo generate 或1$ hexo g 发布本地(到这只能自己爽)1$ hexo server 或1$ hexo s 部署（到这才是显摆）注册登录Github，建库（respositories），名称为user.git.io,如xxxx.git.io找到个人站下的_config.yml,修改部署信息123deploy: type: git repo: https://github.com/user/user.github.io.git 最后执行 1$ hexo deploy 或1$ hexo d","categories":[],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://github.com/b348068721/tags/markdown/"},{"name":"hexo","slug":"hexo","permalink":"https://github.com/b348068721/tags/hexo/"}]}]}